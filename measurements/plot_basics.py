"""Generate basic plots prior to evaluation, i.e., theory and validation (chapters foundation and experimental setup). 
"""
import os
import re

import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
from analysis import savefig
from matplotlib.figure import figaspect
from matplotlib.ticker import MaxNLocator
from run import parse_result

base_path = (
    f"{os.path.dirname(os.path.dirname(os.path.abspath(__file__)))}/base_results"
)


def calc_fpr(k, m, n):
    return (1 - (1 - (1 / m)) ** (k * n)) ** k


def plot_fpr_theo(k_max: int, m: int, n: int):
    """Plots the effects of increasing k for fixed m, n on the false positive rate.
    Highlights the minimum

    Args:
        k_max (int): maximum k for to plot, range [1, k_max]
        m (int): size of the filter bitmap
        n (int): elements to insert
    """
    x = []
    y = []
    min_k, min_f = 0, 100
    for k in range(1, k_max + 1):
        f = calc_fpr(k, m, n) * 100
        x += [k]
        y += [f]
        if f < min_f:
            min_f = f
            min_k = k

    color = ["C0"] * (min_k - 1) + ["C3"] + ["C0"] * (k_max - min_k)

    plt.scatter(x, y, marker="s", color=color, zorder=1)
    plt.plot(x, y, zorder=0)
    plt.xlabel("k")
    plt.ylabel("FPR [%]", labelpad=5)
    plt.title(
        "Theoretical FPR $f$ for varying $k$\nwith $m = 16\,MiB$ and $n = 16000000$"
    )
    plt.xlim(left=0)
    plt.ylim(bottom=0)

    plt.xticks(x)


def read_base_data(figure_id: int) -> pd.DataFrame:
    """Read data generated by rerunning the experiments from Balkesen et al. by the rerun_experiments.sh script

    Args:
        figure_id (int): the figure number in the paper that experiments were rerun for

    Returns:
        pd.DataFrame: the data read
    """
    figure_dir = f"{base_path}/figure{figure_id}"
    data = []
    for f in sorted(os.listdir(figure_dir)):
        with open(f"{figure_dir}/{f}") as file:
            algo, workload, int_val = re.search("([A-Z]+)_(A|B)_(\d+).txt", f).groups()
            res = {}
            if algo in ["NO", "RADIX"]:
                res = parse_wisconsin_result(file.read())
            else:
                res = parse_result(file.read())
            res["int_val"] = int(int_val)
            res["algo"] = algo
            res["workload"] = workload
            data += [res]

    return pd.DataFrame(data)


def parse_wisconsin_result(res: str) -> dict:
    """Parse data from results generated by the code of Blanas et al. located in wisconsin-src

    Args:
        res (str): textual data from the output

    Returns:
        dict: dictionary containing the measurements
    """
    runtime_cycles, build_part, part_cycles = re.search(
        "(\d+)\s+(\d+)\s+(\d+)", res
    ).groups()
    build_cycles = int(build_part) - int(part_cycles)
    return {
        "runtime-cycles": int(runtime_cycles),
        "build-cycles": int(build_cycles),
        "part-cycles": int(part_cycles),
    }


def plot_fig5():
    """Plot reproduced results for figure 5 by Balkesen et al."""
    figure_id = 5
    s_size = 256 * 2**20
    data = read_base_data(figure_id)
    data.rename({"int_val": "nthreads"}, axis=1, inplace=True)
    fig = plt.figure(figsize=figaspect(0.65), layout="constrained")
    ax = fig.gca()

    data["cpt"] = data["runtime-cycles"] / s_size
    data["build-cpt"] = data["build-cycles"] / s_size

    data.pivot(index="nthreads", columns="algo", values="cpt").sort_values(
        by="algo", axis=1
    ).plot(
        kind="bar",
        rot=0,
        ax=ax,
        legend=False,
        color=["#4d4d4d", "#f2f2f2"],
        edgecolor="k",
        linewidth=0.5,
        width=0.5,
        zorder=1,
    )

    data.pivot(index="nthreads", columns="algo", values="build-cpt").sort_values(
        by="algo", axis=1
    ).plot(
        kind="bar",
        rot=0,
        ax=ax,
        legend=False,
        color=["#4d4d4d", "#f2f2f2"],
        edgecolor=["k"],
        linewidth=0.5,
        hatch="///",
        width=0.5,
        zorder=2,
    )

    for no_build_bar in ax.containers[2]:
        no_build_bar.set_edgecolor("w")

    plt.xlabel("number of threads")
    plt.ylabel("cycles per output tuple")
    plt.legend(
        [
            "no partitioning (Blanas et al.)",
            "no partitioning (Balkesen et al.)",
            "build costs (Blanas et al.)",
            "build costs (Balkesen et al.)",
        ],
        loc="upper center",
    )
    add_y_arrow(ax)
    savefig(figure_id)


def plot_fig9():
    """Plot reproduced results for figure 9 by Balkesen et al."""
    figure_id = 9
    s_size = 128 * 10**6
    data = read_base_data(figure_id)
    data.rename({"int_val": "radix_bits"}, axis=1, inplace=True)
    fig = plt.figure(figsize=figaspect(0.81), layout="constrained")
    ax = fig.gca()

    data["cpt"] = data["runtime-cycles"] / s_size
    data["part-cpt"] = data["part-cycles"] / s_size

    ax.bar(
        "radix_bits",
        "cpt",
        label="join cost",
        width=0.4,
        data=data,
        zorder=1,
        linewidth=0.5,
        edgecolor="k",
        facecolor="#e5e5e5",
    )
    ax.bar(
        "radix_bits",
        "part-cpt",
        label="partitioning cost",
        width=0.4,
        data=data,
        zorder=2,
        linewidth=0.5,
        facecolor="#737373",
        edgecolor="k",
    )
    plt.yticks([0, 5, 10, 15, 20, 25, 30, 35])
    plt.xlabel("number of radix bits", labelpad=15)
    plt.ylabel("cycles per output tuple")
    plt.legend(
        loc="upper center",
        ncols=2,
    )
    plt.ylim(top=38)
    add_y_arrow(ax)
    savefig(figure_id)


def plot_fig11():
    """Plot reproduced results for figure 11 by Balkesen et al."""
    figure_id = 11
    s_size = 128 * 10**6
    data = read_base_data(figure_id)
    data.rename({"int_val": "radix_bits"}, axis=1, inplace=True)
    fig = plt.figure(figsize=figaspect(0.59), layout="constrained")
    ax = fig.gca()

    data["join-cpt"] = (data["runtime-cycles"] - data["part-cycles"]) / s_size

    data.pivot(index="radix_bits", columns="algo", values="join-cpt").sort_values(
        by="algo", axis=1, ascending=False
    ).plot(
        kind="bar",
        rot=0,
        ax=ax,
        legend=False,
        color=["#333333", "#8c8c8c", "#f2f2f2"],
        edgecolor="k",
        linewidth=0.5,
    )

    plt.xlabel("number of radix bits")
    plt.ylabel("cycles per output tuple")
    plt.legend(
        [
            "bucket chaining (PRO)",
            "histogram with SIMD (PRHO)",
            "histogram without SIMD (PRH)",
        ],
        loc="upper right",
    )
    ax.yaxis.set_major_locator(MaxNLocator(integer=True))
    add_y_arrow(ax)
    savefig(figure_id)


def plot_fig12():
    """Plot reproduced results for figure 12 by Balkesen et al."""
    figure_id = 12
    s_size = 256 * 2**20
    data = read_base_data(figure_id)
    data.rename({"int_val": "nthreads"}, axis=1, inplace=True)
    fig = plt.figure(figsize=figaspect(0.73), layout="constrained")
    ax = fig.gca()

    data["cpt"] = data["runtime-cycles"] / s_size
    data["part-cpt"] = data["part-cycles"] / s_size

    data.pivot(index="nthreads", columns="algo", values="cpt").sort_values(
        by="algo", axis=1, ascending=False
    ).plot(
        kind="bar",
        rot=0,
        ax=ax,
        legend=False,
        color=["#4d4d4d", "#f2f2f2"],
        edgecolor="k",
        linewidth=0.5,
        width=0.6,
        zorder=1,
    )

    data.pivot(index="nthreads", columns="algo", values="part-cpt").sort_values(
        by="algo", axis=1, ascending=False
    ).plot(
        kind="bar",
        rot=0,
        ax=ax,
        legend=False,
        color=["#4d4d4d", "#f2f2f2"],
        edgecolor=["k"],
        linewidth=0.5,
        hatch="///",
        width=0.6,
        zorder=2,
    )

    for no_build_bar in ax.containers[2]:
        no_build_bar.set_edgecolor("w")

    plt.xlabel("number of threads")
    plt.ylabel("cycles per output tuple")
    plt.legend(
        [
            "radix join (Blanas et al.)",
            "radix join (Balkesen et al.)",
            "partitioning cost (Blanas et al.)",
            "partitioning cost (Balkesen et al.)",
        ],
        loc="upper right",
    )
    add_y_arrow(ax)
    savefig(figure_id)


def add_y_arrow(ax: plt.Axes):
    limits = ax.axis()
    ax.plot(
        limits[0], limits[3], marker="^", markersize=4, color="black", clip_on=False
    )
    ax.axis(limits)


def savefig(figure_id, close=True):
    """Save produced figure to `base_results/figure_<figure_id>.pdf` and `base_results/figure_<figure_id>.pgf`
    and closes the figure if specified

    Args:
        name (str): output filename
        close (bool, optional): closes the figure if applicable.
    """
    plt.savefig(f"{base_path}/figure{figure_id}.pdf")
    plt.savefig(f"{base_path}/figure{figure_id}.pgf")
    if close:
        plt.close()


if __name__ == "__main__":
    matplotlib.use("pgf")
    matplotlib.rcParams.update(
        {
            "pgf.texsystem": "pdflatex",
            "text.usetex": True,
            "pgf.rcfonts": False,
            "font.size": 20,
            "xtick.major.pad": 8,
            "xtick.major.size": 0,
            "ytick.major.size": 10,
            "ytick.direction": "inout",
            "axes.spines.right": False,
            "axes.spines.top": False,
            "legend.framealpha": 0,
            "legend.handlelength": 0.8,
            "legend.handleheight": 0.8,
        }
    )

    plot_fpr_theo(20, 16 * 8 * 1024 * 1024, 16000000)
    savefig("_fpr_theo_foundations")

    plot_fig5()
    plot_fig9()
    plot_fig11()
    plot_fig12()
